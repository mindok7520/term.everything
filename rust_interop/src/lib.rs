#![deny(clippy::all)]

use std::collections::HashMap;
use std::ffi::{c_char, c_void, CString};
use std::os::unix::ffi::OsStrExt;
use std::os::unix::io::{AsRawFd, FromRawFd};
use std::path::PathBuf;
use std::ptr;
use std::sync::Mutex;

use napi::bindgen_prelude::*;
use napi_derive::napi;

// --- Chafa FFI (Foreign Function Interface) ---
// NOTE: These are handwritten FFI bindings for the `chafa` C library.
// In a working build environment, these should be generated by `bindgen` in `build.rs`.
// The signatures are based on the usage in the C++ code.
#[repr(C)]
pub struct GString {
    pub str: *mut c_char,
    pub len: libc::size_t,
    pub allocated_len: libc::size_t,
}

#[repr(C)]
pub struct ChafaSymbolMap;
#[repr(C)]
pub struct ChafaCanvas;

#[allow(non_camel_case_types)]
type gint = libc::c_int;
#[allow(non_camel_case_types)]
type guint = libc::c_uint;
#[allow(non_camel_case_types)]
type gdouble = libc::c_double;
#[allow(non_camel_case_types)]
type gboolean = libc::c_int;

#[link(name = "chafa")]
extern "C" {
    fn chafa_calc_canvas_geometry(
        image_width: gint,
        image_height: gint,
        canvas_width_pixels: *mut gint,
        canvas_height_pixels: *mut gint,
        font_ratio: gdouble,
        center: gboolean,
        scale: gboolean,
    );
    fn g_string_free(string: *mut GString, free_segment: gboolean);
    // This is a simplification. The C++ code calls a method on a ChafaInfo object.
    // I'm creating a plausible C-style function that would be in the bindings.
    // A real implementation would need to match the actual Chafa API.
    fn chafa_canvas_draw_all(
        canvas: *mut ChafaCanvas,
        pixels: *const u8,
        width: gint,
        height: gint,
        rowstride: gint,
    ) -> *mut GString;
}
// --- End Chafa FFI ---

// Represents the C++ SHM_Pool_Memory class
struct ShmPoolMemory {
    addr: *mut c_void,
    size: usize,
    fd: i32,
}

impl ShmPoolMemory {
    fn new(fd: i32, size: usize) -> Result<Self> {
        let addr = unsafe {
            libc::mmap(
                ptr::null_mut(),
                size,
                libc::PROT_READ | libc::PROT_WRITE,
                libc::MAP_SHARED,
                fd,
                0,
            )
        };

        if addr == libc::MAP_FAILED {
            return Err(Error::new(
                Status::GenericFailure,
                "Failed to mmap shared memory".to_string(),
            ));
        }

        Ok(Self { addr, size, fd })
    }

    fn remap(&mut self, new_size: usize) -> Result<()> {
        if self.size == new_size {
            return Ok(());
        }

        // Unmap the old region
        if unsafe { libc::munmap(self.addr, self.size) } == -1 {
            return Err(Error::new(
                Status::GenericFailure,
                "Failed to munmap old region during remap".to_string(),
            ));
        }

        // Mmap the new region
        let new_addr = unsafe {
            libc::mmap(
                ptr::null_mut(),
                new_size,
                libc::PROT_READ | libc::PROT_WRITE,
                libc::MAP_SHARED,
                self.fd,
                0,
            )
        };

        if new_addr == libc::MAP_FAILED {
            self.addr = libc::MAP_FAILED; // Mark as destroyed
            return Err(Error::new(
                Status::GenericFailure,
                "Failed to mmap new region during remap".to_string(),
            ));
        }

        self.addr = new_addr;
        self.size = new_size;
        Ok(())
    }
}

impl Drop for ShmPoolMemory {
    fn drop(&mut self) {
        if self.addr != libc::MAP_FAILED {
            unsafe {
                libc::munmap(self.addr, self.size);
            }
        }
        if self.fd != -1 {
            unsafe {
                libc::close(self.fd);
            }
        }
    }
}

// Represents the C++ ClientState class
#[napi(js_name = "ClientState")]
pub struct ClientState {
    shm_pools: Mutex<HashMap<u32, ShmPoolMemory>>,
}

#[napi]
impl ClientState {
    #[napi(constructor)]
    pub fn new() -> Self {
        ClientState {
            shm_pools: Mutex::new(HashMap::new()),
        }
    }
}

/// Re-implementation of the C++ get_socket_path_from_name function
fn get_socket_path_from_name(socket_name: &str) -> Result<PathBuf> {
    let runtime_dir = std::env::var("XDG_RUNTIME_DIR")
        .map_err(|e| Error::new(Status::GenericFailure, format!("Failed to get XDG_RUNTIME_DIR: {}", e)))?;
    Ok(PathBuf::from(runtime_dir).join(socket_name))
}

/// Translation of listen_to_wayland_socket_js
#[napi]
pub fn listen_to_wayland_socket(socket_name: String) -> Result<i32> {
    let socket_path = get_socket_path_from_name(&socket_name)?;

    // Remove the file if it exists
    if socket_path.exists() {
        std::fs::remove_file(&socket_path).map_err(|e| {
            Error::new(
                Status::GenericFailure,
                format!("Failed to remove existing socket file: {}", e),
            )
        })?;
    }

    // Create and bind the socket using std::os::unix::net::UnixListener
    let listener = std::os::unix::net::UnixListener::bind(&socket_path).map_err(|e| {
        Error::new(
            Status::GenericFailure,
            format!("Failed to bind socket: {}", e),
        )
    })?;

    // Return the raw file descriptor
    Ok(listener.as_raw_fd())
}

/// Translation of mmap_shm_pool_js
#[napi]
pub fn mmap_shm_pool(client_state: External<ClientState>, fd: i32, size: i64, shm_pool_id: u32) -> Result<bool> {
    let mut pools = client_state.shm_pools.lock().unwrap();
    if pools.contains_key(&shm_pool_id) {
        return Ok(false); // Already exists
    }

    let pool = ShmPoolMemory::new(fd, size as usize)?;
    pools.insert(shm_pool_id, pool);
    Ok(true)
}

/// Translation of remap_shm_pool_js
#[napi]
pub fn remap_shm_pool(client_state: External<ClientState>, shm_pool_id: u32, new_size: i64) -> Result<bool> {
    let mut pools = client_state.shm_pools.lock().unwrap();
    if let Some(pool) = pools.get_mut(&shm_pool_id) {
        if pool.remap(new_size as usize).is_err() {
            // Remap failed, remove the pool
            pools.remove(&shm_pool_id);
            return Ok(false);
        }
        Ok(true)
    } else {
        Ok(false) // Pool not found
    }
}

/// Translation of unmmap_shm_pool_js
#[napi]
pub fn unmmap_shm_pool(client_state: External<ClientState>, shm_pool_id: u32) {
    let mut pools = client_state.shm_pools.lock().unwrap();
    pools.remove(&shm_pool_id);
}

/// Translation of draw_desktop_js
#[napi]
pub fn draw_desktop(
    // The Draw_State external object is not used in the C++ snippet, so I'm omitting it.
    // It would be another External<T> if needed.
    desktop_buffer: Buffer,
    width: u32,
    height: u32,
    status_line: String,
) -> Result<Object> {
    // Get terminal dimensions
    let (term_width_cols, term_height_rows) =
        term_size::dimensions().ok_or_else(|| Error::new(Status::GenericFailure, "Could not get terminal size"))?;

    let have_status_line = !status_line.is_empty();
    let status_line_height = if have_status_line { 1 } else { 0 };

    let mut canvas_width = term_width_cols as i32;
    // Assuming font ratio is 1.0 for simplicity. The C++ code gets this from somewhere.
    let font_ratio = 1.0;
    let mut canvas_height = (term_height_rows - status_line_height) as i32;

    // Call the (unsafe) FFI function
    unsafe {
        chafa_calc_canvas_geometry(
            width as i32,
            height as i32,
            &mut canvas_width,
            &mut canvas_height,
            font_ratio,
            1, // TRUE
            0, // FALSE
        );
    }

    // This part is highly speculative as it depends on the real Chafa API and bindings
    let printable: *mut GString = unsafe {
        // This is a placeholder for the real Chafa drawing logic.
        // The C++ code has a `Draw_State` object that holds a `ChafaInfo` which does the conversion.
        // A real implementation would need to create and manage a ChafaCanvas.
        // For now, we assume a function exists that takes pixel data and returns a GString.
        // Let's return an empty string to avoid a segfault if this code were to be run.
        let empty_c_str = CString::new("").unwrap();
        let g_string = GString {
            str: empty_c_str.into_raw(),
            len: 0,
            allocated_len: 1,
        };
        Box::into_raw(Box::new(g_string))
    };

    // Build the output string
    let mut output = String::new();
    if have_status_line {
        // ANSI escape codes from C++ code
        let move_cursor_to_home = "\x1B[H";
        let clear_line_after_cursor = "\x1B[K";
        output.push_str(move_cursor_to_home);
        output.push_str(&status_line);
        output.push_str(clear_line_after_cursor);
        output.push('\n');
    }

    if !printable.is_null() {
        let printable_str = unsafe { std::ffi::CStr::from_ptr((*printable).str).to_string_lossy() };
        output.push_str(&printable_str);
        unsafe {
            // Free the GString allocated by Chafa
            g_string_free(printable, 1);
        }
    }

    // Write to stdout
    print!("{}", output);
    use std::io::Write;
    std::io::stdout().flush().unwrap();

    // Return canvas size object
    let mut result_obj = env.create_object()?;
    result_obj.set("width_cells", canvas_width)?;
    result_obj.set("height_cells", canvas_height)?;

    Ok(result_obj)
}
